{
  "name": "portainer",
  "description": "Container management and monitoring interface for LearningLab platform",
  "version": "1.0.0",
  "phase": 4,
  "priority": "medium",
  "dependencies": {
    "runtime": "docker",
    "tools": [
      "docker",
      "docker-compose",
      "portainer/portainer-ce",
      "portainer/agent"
    ],
    "system": ["docker", "docker-compose"]
  },
  "configuration": {
    "command": "docker",
    "args": ["run", "-d", "--name", "portainer", "-p", "9000:9000", "-v", "/var/run/docker.sock:/var/run/docker.sock", "-v", "portainer_data:/data", "portainer/portainer-ce:latest"],
    "environment": {
      "PORTAINER_HTTP_PORT": "9000",
      "PORTAINER_HTTPS_PORT": "9443",
      "PORTAINER_DATA_DIR": "/data",
      "PORTAINER_ADMIN_PASSWORD": "${PORTAINER_ADMIN_PASSWORD}",
      "PORTAINER_EDGE_KEY": "${PORTAINER_EDGE_KEY}",
      "PORTAINER_LOGO_URL": "https://learninglab.example.com/logo.png",
      "PORTAINER_TEMPLATES_URL": "https://raw.githubusercontent.com/portainer/templates/master/templates.json"
    },
    "security": {
      "authentication": "internal",
      "ssl_enabled": true,
      "rbac_enabled": true,
      "session_timeout": "8h",
      "password_policy": "strong"
    }
  },
  "deployment_modes": {
    "standalone": {
      "description": "Single Portainer instance for development",
      "docker_compose": {
        "version": "3.8",
        "services": {
          "portainer": {
            "image": "portainer/portainer-ce:latest",
            "container_name": "portainer",
            "restart": "unless-stopped",
            "ports": ["9000:9000", "9443:9443"],
            "volumes": [
              "/var/run/docker.sock:/var/run/docker.sock",
              "portainer_data:/data"
            ],
            "environment": {
              "PORTAINER_ADMIN_PASSWORD_FILE": "/run/secrets/portainer_admin_password"
            },
            "secrets": ["portainer_admin_password"],
            "labels": {
              "traefik.enable": "true",
              "traefik.http.routers.portainer.rule": "Host(`portainer.learninglab.local`)",
              "traefik.http.services.portainer.loadbalancer.server.port": "9000"
            }
          }
        },
        "volumes": {
          "portainer_data": {}
        },
        "secrets": {
          "portainer_admin_password": {
            "file": "./secrets/portainer_admin_password.txt"
          }
        }
      }
    },
    "kubernetes": {
      "description": "Portainer deployed in Kubernetes cluster",
      "namespace": "portainer",
      "deployment": {
        "apiVersion": "apps/v1",
        "kind": "Deployment",
        "metadata": {
          "name": "portainer",
          "namespace": "portainer",
          "labels": {
            "app": "portainer"
          }
        },
        "spec": {
          "replicas": 1,
          "selector": {
            "matchLabels": {
              "app": "portainer"
            }
          },
          "template": {
            "metadata": {
              "labels": {
                "app": "portainer"
              }
            },
            "spec": {
              "serviceAccountName": "portainer-sa",
              "containers": [
                {
                  "name": "portainer",
                  "image": "portainer/portainer-ce:latest",
                  "ports": [
                    {"containerPort": 9000, "name": "http"},
                    {"containerPort": 9443, "name": "https"}
                  ],
                  "resources": {
                    "requests": {"cpu": "100m", "memory": "128Mi"},
                    "limits": {"cpu": "500m", "memory": "512Mi"}
                  },
                  "env": [
                    {"name": "PORTAINER_K8S_MODE", "value": "true"}
                  ],
                  "volumeMounts": [
                    {"name": "data", "mountPath": "/data"}
                  ]
                }
              ],
              "volumes": [
                {
                  "name": "data",
                  "persistentVolumeClaim": {
                    "claimName": "portainer-data"
                  }
                }
              ]
            }
          }
        }
      },
      "service": {
        "apiVersion": "v1",
        "kind": "Service",
        "metadata": {
          "name": "portainer",
          "namespace": "portainer"
        },
        "spec": {
          "type": "ClusterIP",
          "ports": [
            {"port": 9000, "targetPort": 9000, "name": "http"},
            {"port": 9443, "targetPort": 9443, "name": "https"}
          ],
          "selector": {
            "app": "portainer"
          }
        }
      },
      "ingress": {
        "apiVersion": "networking.k8s.io/v1",
        "kind": "Ingress",
        "metadata": {
          "name": "portainer",
          "namespace": "portainer",
          "annotations": {
            "nginx.ingress.kubernetes.io/ssl-redirect": "true",
            "cert-manager.io/cluster-issuer": "letsencrypt-prod"
          }
        },
        "spec": {
          "tls": [
            {
              "hosts": ["portainer.learninglab.example.com"],
              "secretName": "portainer-tls"
            }
          ],
          "rules": [
            {
              "host": "portainer.learninglab.example.com",
              "http": {
                "paths": [
                  {
                    "path": "/",
                    "pathType": "Prefix",
                    "backend": {
                      "service": {
                        "name": "portainer",
                        "port": {"number": 9000}
                      }
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    },
    "swarm": {
      "description": "Portainer in Docker Swarm mode",
      "stack_file": {
        "version": "3.8",
        "services": {
          "portainer": {
            "image": "portainer/portainer-ce:latest",
            "ports": ["9000:9000", "9443:9443"],
            "volumes": [
              "/var/run/docker.sock:/var/run/docker.sock",
              "portainer_data:/data"
            ],
            "deploy": {
              "mode": "replicated",
              "replicas": 1,
              "placement": {
                "constraints": ["node.role == manager"]
              },
              "restart_policy": {
                "condition": "on-failure",
                "delay": "5s",
                "max_attempts": 3
              }
            },
            "networks": ["portainer"]
          },
          "agent": {
            "image": "portainer/agent:latest",
            "volumes": [
              "/var/run/docker.sock:/var/run/docker.sock",
              "/var/lib/docker/volumes:/var/lib/docker/volumes"
            ],
            "deploy": {
              "mode": "global",
              "placement": {
                "constraints": ["node.platform.os == linux"]
              }
            },
            "networks": ["portainer"]
          }
        },
        "networks": {
          "portainer": {
            "driver": "overlay",
            "attachable": true
          }
        },
        "volumes": {
          "portainer_data": {}
        }
      }
    }
  },
  "features": {
    "container_management": {
      "description": "Comprehensive container lifecycle management",
      "capabilities": [
        "Create, start, stop, restart containers",
        "View container logs and statistics",
        "Execute commands in running containers",
        "Inspect container configuration",
        "Manage container networks and volumes"
      ]
    },
    "image_management": {
      "description": "Docker image operations and registry integration",
      "capabilities": [
        "Pull images from registries",
        "Build images from Dockerfiles",
        "Tag and push images",
        "Scan images for vulnerabilities",
        "Manage image repositories"
      ]
    },
    "stack_deployment": {
      "description": "Deploy and manage application stacks",
      "capabilities": [
        "Deploy Docker Compose stacks",
        "Kubernetes application deployment",
        "Template-based deployments",
        "Stack versioning and rollback",
        "Environment variable management"
      ]
    },
    "monitoring_analytics": {
      "description": "Real-time monitoring and analytics",
      "capabilities": [
        "Resource usage monitoring",
        "Container health checks",
        "Performance metrics",
        "Log aggregation and search",
        "Alert notifications"
      ]
    },
    "user_management": {
      "description": "Multi-user access control",
      "capabilities": [
        "Role-based access control",
        "Team management",
        "Resource permissions",
        "Authentication integration",
        "Audit logging"
      ]
    }
  },
  "use_cases": {
    "phase_4_1_container_orchestration": {
      "description": "Manage LearningLab containers through Portainer interface",
      "workflow": [
        {
          "step": "setup_portainer",
          "operations": ["deployPortainer", "configureAuthentication", "setupTeams"],
          "resources": ["portainer-deployment", "user-accounts", "rbac-policies"]
        },
        {
          "step": "connect_environments",
          "operations": ["addDockerEndpoint", "addKubernetesCluster", "configureAgents"],
          "resources": ["docker-endpoint", "k8s-cluster", "portainer-agents"]
        },
        {
          "step": "deploy_applications",
          "operations": ["createStacks", "deployServices", "configureNetworking"],
          "resources": ["compose-stacks", "k8s-applications", "networks"]
        },
        {
          "step": "monitor_manage",
          "operations": ["viewMetrics", "manageLogs", "performMaintenance"],
          "resources": ["dashboards", "log-viewer", "maintenance-tasks"]
        }
      ],
      "benefits": [
        "Simplified container management",
        "Visual interface for complex operations",
        "Team collaboration features",
        "Centralized monitoring and logging"
      ]
    },
    "development_workflow": {
      "description": "Support development team with container operations",
      "scenarios": [
        {
          "name": "local_development",
          "description": "Manage development containers",
          "steps": [
            "Connect to local Docker daemon",
            "Deploy development stack",
            "Monitor application logs",
            "Debug container issues",
            "Update and redeploy services"
          ]
        },
        {
          "name": "staging_deployment",
          "description": "Deploy to staging environment",
          "steps": [
            "Connect to staging cluster",
            "Deploy application stack",
            "Configure environment variables",
            "Run integration tests",
            "Monitor performance metrics"
          ]
        },
        {
          "name": "production_management",
          "description": "Manage production containers",
          "steps": [
            "Monitor production health",
            "Scale services as needed",
            "Perform rolling updates",
            "Investigate issues",
            "Backup and restore data"
          ]
        }
      ]
    },
    "learninglab_specific": {
      "description": "LearningLab platform specific use cases",
      "applications": [
        {
          "name": "ai_service_management",
          "description": "Manage AI and ML containers",
          "containers": ["jupyter-notebook", "tensorflow-serving", "pytorch-inference"],
          "operations": ["scale-gpu-workloads", "monitor-model-performance", "update-models"]
        },
        {
          "name": "database_operations",
          "description": "Manage database containers",
          "containers": ["postgresql", "redis", "elasticsearch"],
          "operations": ["backup-databases", "monitor-performance", "scale-read-replicas"]
        },
        {
          "name": "web_services",
          "description": "Manage web application containers",
          "containers": ["frontend", "api-server", "nginx"],
          "operations": ["rolling-updates", "load-balancing", "ssl-certificate-management"]
        }
      ]
    }
  },
  "templates": {
    "learninglab_stack": {
      "name": "LearningLab Complete Stack",
      "description": "Full LearningLab platform deployment",
      "type": "docker-compose",
      "template": {
        "version": "3.8",
        "services": {
          "frontend": {
            "image": "learninglab/frontend:latest",
            "ports": ["3000:3000"],
            "environment": {
              "REACT_APP_API_URL": "http://localhost:8000"
            },
            "depends_on": ["api"]
          },
          "api": {
            "image": "learninglab/api:latest",
            "ports": ["8000:8000"],
            "environment": {
              "DATABASE_URL": "postgresql://postgres:password@postgres:5432/learninglab",
              "REDIS_URL": "redis://redis:6379"
            },
            "depends_on": ["postgres", "redis"]
          },
          "postgres": {
            "image": "postgres:15-alpine",
            "environment": {
              "POSTGRES_DB": "learninglab",
              "POSTGRES_USER": "postgres",
              "POSTGRES_PASSWORD": "password"
            },
            "volumes": ["postgres_data:/var/lib/postgresql/data"]
          },
          "redis": {
            "image": "redis:7-alpine",
            "volumes": ["redis_data:/data"]
          },
          "jupyter": {
            "image": "jupyter/tensorflow-notebook:latest",
            "ports": ["8888:8888"],
            "environment": {
              "JUPYTER_ENABLE_LAB": "yes"
            },
            "volumes": ["jupyter_data:/home/jovyan/work"]
          }
        },
        "volumes": {
          "postgres_data": {},
          "redis_data": {},
          "jupyter_data": {}
        }
      }
    },
    "ai_development": {
      "name": "AI Development Environment",
      "description": "AI/ML development and training environment",
      "type": "docker-compose",
      "template": {
        "version": "3.8",
        "services": {
          "jupyter": {
            "image": "jupyter/tensorflow-notebook:latest",
            "ports": ["8888:8888"],
            "environment": {
              "JUPYTER_ENABLE_LAB": "yes",
              "GRANT_SUDO": "yes"
            },
            "volumes": [
              "./notebooks:/home/jovyan/work",
              "./data:/home/jovyan/data"
            ]
          },
          "mlflow": {
            "image": "python:3.9",
            "ports": ["5000:5000"],
            "command": "pip install mlflow && mlflow server --host 0.0.0.0",
            "volumes": ["mlflow_data:/mlflow"]
          },
          "tensorboard": {
            "image": "tensorflow/tensorflow:latest",
            "ports": ["6006:6006"],
            "command": "tensorboard --logdir=/logs --host=0.0.0.0",
            "volumes": ["./logs:/logs"]
          }
        },
        "volumes": {
          "mlflow_data": {}
        }
      }
    },
    "monitoring_stack": {
      "name": "Monitoring and Observability",
      "description": "Complete monitoring solution",
      "type": "docker-compose",
      "template": {
        "version": "3.8",
        "services": {
          "prometheus": {
            "image": "prom/prometheus:latest",
            "ports": ["9090:9090"],
            "volumes": [
              "./prometheus.yml:/etc/prometheus/prometheus.yml",
              "prometheus_data:/prometheus"
            ]
          },
          "grafana": {
            "image": "grafana/grafana:latest",
            "ports": ["3000:3000"],
            "environment": {
              "GF_SECURITY_ADMIN_PASSWORD": "admin"
            },
            "volumes": ["grafana_data:/var/lib/grafana"]
          },
          "node_exporter": {
            "image": "prom/node-exporter:latest",
            "ports": ["9100:9100"]
          },
          "cadvisor": {
            "image": "gcr.io/cadvisor/cadvisor:latest",
            "ports": ["8080:8080"],
            "volumes": [
              "/:/rootfs:ro",
              "/var/run:/var/run:ro",
              "/sys:/sys:ro",
              "/var/lib/docker/:/var/lib/docker:ro"
            ]
          }
        },
        "volumes": {
          "prometheus_data": {},
          "grafana_data": {}
        }
      }
    }
  },
  "integrations": {
    "ci_cd": {
      "github_actions": {
        "description": "Deploy via GitHub Actions",
        "workflow": {
          "name": "Deploy to Portainer",
          "on": ["push"],
          "jobs": {
            "deploy": {
              "runs-on": "ubuntu-latest",
              "steps": [
                {"uses": "actions/checkout@v3"},
                {
                  "name": "Deploy Stack",
                  "run": "curl -X POST \"$PORTAINER_URL/api/stacks\" -H \"X-API-Key: $PORTAINER_API_KEY\" -F \"Name=learninglab\" -F \"SwarmID=$SWARM_ID\" -F \"file=@docker-compose.yml\""
                }
              ]
            }
          }
        }
      },
      "gitlab_ci": {
        "description": "Deploy via GitLab CI",
        "pipeline": {
          "stages": ["build", "deploy"],
          "deploy": {
            "stage": "deploy",
            "script": [
              "curl -X POST \"$PORTAINER_URL/api/stacks\" -H \"X-API-Key: $PORTAINER_API_KEY\" -F \"Name=learninglab\" -F \"SwarmID=$SWARM_ID\" -F \"file=@docker-compose.yml\""
            ],
            "only": ["main"]
          }
        }
      }
    },
    "external_tools": {
      "docker_registry": {
        "description": "Integration with Docker registries",
        "supported": ["Docker Hub", "GitHub Container Registry", "AWS ECR", "Azure ACR", "Google GCR"],
        "configuration": {
          "authentication": "api_key_or_username_password",
          "webhook_support": true,
          "auto_update": true
        }
      },
      "kubernetes": {
        "description": "Kubernetes cluster management",
        "features": [
          "Cluster connection",
          "Namespace management",
          "Resource deployment",
          "Helm chart deployment",
          "RBAC configuration"
        ]
      },
      "monitoring": {
        "description": "Integration with monitoring tools",
        "supported": ["Prometheus", "Grafana", "Datadog", "New Relic"],
        "metrics": [
          "Container resource usage",
          "Application performance",
          "Infrastructure health",
          "Custom business metrics"
        ]
      }
    }
  },
  "security": {
    "authentication": {
      "methods": ["internal", "ldap", "oauth", "saml"],
      "mfa_support": true,
      "session_management": {
        "timeout": "8h",
        "concurrent_sessions": 5,
        "secure_cookies": true
      }
    },
    "authorization": {
      "rbac": {
        "roles": ["admin", "operator", "developer", "viewer"],
        "permissions": [
          "container_management",
          "image_management",
          "stack_deployment",
          "user_management",
          "system_configuration"
        ]
      },
      "resource_access": {
        "endpoint_restrictions": true,
        "namespace_isolation": true,
        "team_based_access": true
      }
    },
    "network_security": {
      "ssl_tls": {
        "enabled": true,
        "certificate_management": "automatic",
        "min_tls_version": "1.2"
      },
      "firewall": {
        "ip_whitelist": true,
        "rate_limiting": true,
        "ddos_protection": true
      }
    },
    "data_protection": {
      "encryption": {
        "data_at_rest": true,
        "data_in_transit": true,
        "secret_management": true
      },
      "backup": {
        "automated_backups": true,
        "encryption": true,
        "retention_policy": "30d"
      }
    }
  },
  "monitoring": {
    "health_check": {
      "command": "curl -f http://localhost:9000/api/status || exit 1",
      "interval": 30,
      "timeout": 10,
      "retries": 3
    },
    "metrics": {
      "portainer_users_total": "Total number of Portainer users",
      "portainer_endpoints_total": "Total number of connected endpoints",
      "portainer_stacks_total": "Total number of deployed stacks",
      "portainer_containers_total": "Total number of managed containers",
      "portainer_api_requests_total": "Total number of API requests",
      "portainer_response_time_seconds": "API response time in seconds"
    },
    "alerts": {
      "endpoint_disconnected": {
        "condition": "endpoint_status != 'up'",
        "severity": "warning",
        "notification": ["email", "slack"]
      },
      "high_resource_usage": {
        "condition": "container_cpu_usage > 90% OR container_memory_usage > 90%",
        "severity": "critical",
        "notification": ["email", "slack", "pagerduty"]
      },
      "failed_deployment": {
        "condition": "stack_deployment_status == 'failed'",
        "severity": "high",
        "notification": ["email", "slack"]
      }
    },
    "logging": {
      "access_logs": true,
      "audit_logs": true,
      "error_logs": true,
      "retention": "90d",
      "format": "json"
    }
  },
  "testing": {
    "unit_tests": [
      {
        "name": "test_portainer_deployment",
        "description": "Test Portainer container deployment",
        "command": "docker run --rm -d --name test-portainer -p 9001:9000 portainer/portainer-ce:latest",
        "validation": "curl -f http://localhost:9001/api/status",
        "cleanup": "docker stop test-portainer"
      }
    ],
    "integration_tests": [
      {
        "name": "test_stack_deployment",
        "description": "Test application stack deployment through Portainer",
        "steps": [
          "Deploy test stack via API",
          "Verify all services are running",
          "Test service connectivity",
          "Remove test stack"
        ]
      },
      {
        "name": "test_kubernetes_integration",
        "description": "Test Kubernetes cluster management",
        "steps": [
          "Connect to test Kubernetes cluster",
          "Deploy test application",
          "Verify deployment status",
          "Scale application",
          "Clean up resources"
        ]
      }
    ],
    "performance_tests": [
      {
        "name": "test_api_performance",
        "description": "Test Portainer API performance under load",
        "tool": "artillery",
        "config": {
          "target": "http://localhost:9000",
          "phases": [
            {"duration": 60, "arrivalRate": 10},
            {"duration": 120, "arrivalRate": 50}
          ]
        }
      }
    ]
  },
  "best_practices": {
    "deployment": [
      "Use persistent volumes for Portainer data",
      "Enable SSL/TLS for production deployments",
      "Configure proper backup strategies",
      "Use secrets management for sensitive data",
      "Implement proper network security"
    ],
    "management": [
      "Regularly update Portainer to latest version",
      "Monitor resource usage and performance",
      "Implement proper user access controls",
      "Use teams and roles for organization",
      "Document deployment procedures"
    ],
    "security": [
      "Enable multi-factor authentication",
      "Use strong passwords and API keys",
      "Regularly audit user access",
      "Monitor for suspicious activities",
      "Keep container images updated"
    ],
    "operations": [
      "Automate deployments where possible",
      "Use infrastructure as code",
      "Implement proper monitoring and alerting",
      "Test disaster recovery procedures",
      "Maintain comprehensive documentation"
    ]
  }
}