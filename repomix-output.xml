This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    api.yaml
    web.yaml
.repomix/
  bundles.json
apps/
  api/
    prisma/
      migrations/
        20220307034109_initial_migrate/
          migration.sql
        20250517073440_add_user_auth_fields/
          migration.sql
        migration_lock.toml
      schema.prisma
    src/
      auth/
        strategies/
          jwt/
            jwt.ts
          local/
            local.ts
        auth.controller.ts
        auth.module.ts
        auth.service.ts
      config/
        environment-variables.ts
      persistence/
        prisma/
          prisma.service.spec.ts
          prisma.service.ts
        persistence.module.ts
      users/
        dto/
          create-user.dto.ts
        users.controller.spec.ts
        users.controller.ts
        users.module.ts
        users.service.spec.ts
        users.service.ts
      app.controller.spec.ts
      app.controller.ts
      app.module.ts
      app.service.ts
      main.ts
    test/
      app.e2e-spec.ts
      jest-e2e.json
    .eslintrc.js
    .prettierrc
    Dockerfile
    nest-cli.json
    package.json
    tsconfig.build.json
    tsconfig.json
    webpack-hmr.config.js
  web/
    pages/
      _app.tsx
      index.tsx
    src/
      screens/
        auth/
          login/
            login.test.tsx
            login.tsx
      store/
        services/
          api.ts
        index.ts
      styles/
        global.css
    .eslintrc.js
    Dockerfile
    jest.config.js
    jest.setup.js
    next-env.d.ts
    next.config.js
    package.json
    postcss.config.js
    README.md
    tailwind.config.js
    tsconfig.json
packages/
  config/
    eslint-preset.js
    nginx.conf
    package.json
    postcss.config.js
    tailwind.config.js
  tsconfig/
    base.json
    nestjs.json
    nextjs.json
    package.json
    react-library.json
    README.md
  ui/
    components/
      Button/
        Button.tsx
    index.tsx
    package.json
    tsconfig.json
.dockerignore
.gitignore
docker-compose.yml
LICENSE
package-scripts.js
package.json
README.md
terminal.txt
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/api/src/auth/strategies/jwt/jwt.ts">
export class Jwt {}
</file>

<file path="apps/api/src/auth/strategies/local/local.ts">
// apps/api/src/auth/strategies/local.strategy.ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { User } from '@prisma/client';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: 'email' }); // Fortæller Passport at 'email' feltet skal bruges som brugernavn
  }

  // Denne metode kaldes automatisk af Passport, når LocalAuthGuard bruges
  async validate(email: string, pass: string): Promise<Omit<User, 'passwordHash'>> {
    // Kald AuthService for at validere brugerens email og password
    const user = await this.authService.validateUser(email, pass);
    if (!user) {
      // Hvis brugeren ikke findes eller password er forkert, kast en UnauthorizedException
      throw new UnauthorizedException('Ugyldig email eller password.');
    }
    // Returner brugerobjektet (uden passwordHash), som så bliver tilgængeligt på req.user
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { passwordHash, ...result } = user;
    return result;
  }
}
</file>

<file path="apps/api/src/auth/auth.controller.ts">
import { Controller } from '@nestjs/common';

@Controller('auth')
export class AuthController {}
</file>

<file path="apps/api/src/auth/auth.module.ts">
// apps/api/src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module'; // Importer UsersModule for at få adgang til UsersService
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { LocalStrategy } from './strategies/local.strategy';
import { JwtStrategy } from './strategies/jwt.strategy';
import { ConfigModule, ConfigService } from '@nestjs/config'; // Importer ConfigModule og ConfigService

@Module({
  imports: [
    UsersModule, // Gør UsersService tilgængelig i AuthModule
    PassportModule.register({ defaultStrategy: 'jwt' }), // Registrer PassportModule, default strategi er jwt
    JwtModule.registerAsync({
      // Konfigurer JwtModule asynkront for at kunne bruge ConfigService
      imports: [ConfigModule], // Importer ConfigModule for at få adgang til miljøvariabler
      inject: [ConfigService], // Injicer ConfigService
      useFactory: async (configService: ConfigService) => ({
        // Brug en factory funktion til at definere JWT optioner dynamisk
        // Hent JWT_SECRET og JWT_EXPIRES_IN fra miljøvariabler via ConfigService
        // Sørg for at have disse defineret i din .env fil (f.eks. JWT_SECRET=DIN_SUPER_HEMMELIGE_NØGLE og JWT_EXPIRES_IN=3600s)
        secret: configService.get<string>('JWT_SECRET') || 'DEFAULT_VERY_SECRET_KEY_CHANGE_ME_IN_ENV', // Fallback hvis ikke sat i .env
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN') || '1h', // Token udløber om 1 time som default
        },
      }),
    }),
    ConfigModule, // Sørg for at ConfigModule er importeret, hvis den ikke er global i AppModule
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    LocalStrategy, // Tilføj LocalStrategy til providers
    JwtStrategy,   // Tilføj JwtStrategy til providers
  ],
  exports: [AuthService, JwtModule], // Eksporter AuthService og JwtModule så de kan bruges i andre moduler (f.eks. til Guards)
})
export class AuthModule {}
</file>

<file path="apps/api/src/auth/auth.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AuthService {}
</file>

<file path=".github/workflows/web.yaml">
# This is a basic workflow to help you get started with Actions

name: web-ci

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [master]
    paths:
      - "apps/web/**"
  pull_request:
    branches: [master]
    paths:
      - "apps/web/**"

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    strategy:
      matrix:
        node-version: [16.x]

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Cache node modules
        uses: actions/cache@v2
        id: yarn-cache # use this to check for `cache-hit` (`steps.yarn-cache.outputs.cache-hit != 'true'`)
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - run: yarn global add turbo
      - run: npx nps prepare.ci.web
      - run: npx nps build.ci.web
      - run: npx nps test.ci.web
</file>

<file path=".repomix/bundles.json">
{
  "bundles": {}
}
</file>

<file path="apps/api/prisma/migrations/20220307034109_initial_migrate/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
</file>

<file path="apps/api/prisma/migrations/20250517073440_add_user_auth_fields/migration.sql">
/*
  Warnings:

  - Added the required column `passwordHash` to the `User` table without a default value. This is not possible if the table is not empty.
  - Added the required column `updatedAt` to the `User` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "passwordHash" TEXT NOT NULL,
ADD COLUMN     "role" "Role" NOT NULL DEFAULT 'USER',
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL;
</file>

<file path="apps/api/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="apps/api/src/config/environment-variables.ts">
import * as Joi from 'joi';

export interface EnvironmentVariables {
  DATABASE_URL: string;
}

export const validationSchemaForEnv = Joi.object<EnvironmentVariables, true>({
  DATABASE_URL: Joi.string().required(),
});
</file>

<file path="apps/api/src/persistence/prisma/prisma.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaService } from './prisma.service';

describe('PrismaService', () => {
  let service: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PrismaService],
    }).compile();

    service = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="apps/api/src/persistence/persistence.module.ts">
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma/prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PersistenceModule {}
</file>

<file path="apps/api/src/users/dto/create-user.dto.ts">
// apps/api/src/users/dto/create-user.dto.ts
    import { IsEmail, IsNotEmpty, IsString, MinLength, IsEnum, IsOptional } from 'class-validator';
    import { Role } from '@prisma/client'; // Importer Role enum fra Prisma Client

    export class CreateUserDto {
      @IsEmail({}, { message: 'Email skal være en gyldig email-adresse.' })
      @IsNotEmpty({ message: 'Email må ikke være tom.' })
      email: string;

      @IsString({ message: 'Password skal være en streng.' })
      @MinLength(8, { message: 'Password skal være mindst 8 tegn langt.' })
      @IsNotEmpty({ message: 'Password må ikke være tomt.' })
      password: string;

      @IsString({ message: 'Navn skal være en streng.' })
      @IsOptional() // Gør navnefeltet valgfrit
      name?: string;

      // Baseret på din schema.prisma, hvor en bruger har én 'role'
      @IsEnum(Role, { message: 'Rolle skal være en gyldig værdi (USER eller ADMIN).' })
      @IsOptional() // Gør rollen valgfri ved oprettelse, så den kan falde tilbage til default i schema
      role?: Role;
    }
</file>

<file path="apps/api/src/users/users.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { UsersController } from './users.controller';

describe('UsersController', () => {
  let controller: UsersController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
    }).compile();

    controller = module.get<UsersController>(UsersController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="apps/api/src/users/users.controller.ts">
// apps/api/src/users/users.controller.ts
import { Controller, Post, Body, ValidationPipe, UsePipes, HttpCode, HttpStatus } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { User } from '@prisma/client'; // Importer User type for returtypen

@Controller('users') // Alle ruter i denne controller vil starte med /users
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  // Definerer en POST-rute til /users/signup
  // @UsePipes(...) aktiverer automatisk validering af request body'en baseret på CreateUserDto
  // @HttpCode(...) sætter HTTP statuskoden til 201 Created ved succesfuld oprettelse
  @Post('signup')
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true, forbidNonWhitelisted: true }))
  @HttpCode(HttpStatus.CREATED)
  async signUp(@Body() createUserDto: CreateUserDto): Promise<Omit<User, 'passwordHash'>> {
    // @Body() decorator tager request body'en og mapper den til createUserDto
    // UsersService.create kaldes for at håndtere selve brugeroprettelsen
    return this.usersService.create(createUserDto);
  }

  // Her kan andre endpoints tilføjes senere, f.eks.:
  // @Get()
  // findAll() { ... }

  // @Get(':id')
  // findOne(@Param('id') id: string) { ... }
}
</file>

<file path="apps/api/src/users/users.module.ts">
// apps/api/src/users/users.module.ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { PersistenceModule } from '../persistence/persistence.module'; // Importer PersistenceModule, der indeholder PrismaService

@Module({
  imports: [PersistenceModule], // Gør PrismaService tilgængelig for UsersService
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService], // Gør UsersService tilgængelig for andre moduler (f.eks. AuthModule senere)
})
export class UsersModule {}
</file>

<file path="apps/api/src/users/users.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="apps/api/src/users/users.service.ts">
// apps/api/src/users/users.service.ts
import { Injectable, ConflictException, InternalServerErrorException } from '@nestjs/common';
import { PrismaService } from '../persistence/prisma/prisma.service'; // Sti til din PrismaService
import { CreateUserDto } from './dto/create-user.dto';
import * as bcrypt from 'bcryptjs';
import { User, Role } from '@prisma/client'; // Importer User og Role typer fra Prisma

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async create(createUserDto: CreateUserDto): Promise<Omit<User, 'passwordHash'>> {
    const { email, password, name, role } = createUserDto;

    // Tjek om brugeren allerede eksisterer
    const existingUser = await this.prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('En bruger med denne email eksisterer allerede.');
    }

    // Hash passwordet
    const saltRounds = 10; // Anbefalet antal "salt rounds" for bcrypt
    let hashedPassword;
    try {
      hashedPassword = await bcrypt.hash(password, saltRounds);
    } catch (error) {
      // Log den faktiske fejl internt
      console.error('Fejl under hashing af password:', error);
      // Vis en generisk fejl til klienten
      throw new InternalServerErrorException('Der opstod en intern fejl under brugeroprettelse (hashing).');
    }

    // Opret brugeren i databasen
    try {
      const user = await this.prisma.user.create({
        data: {
          email,
          passwordHash: hashedPassword, // Gem det hashede password
          name: name || null, // Sæt til null hvis name ikke er angivet i DTO'en
          role: role || Role.USER, // Brug den angivne rolle fra DTO'en, eller default til USER hvis ikke angivet
        },
      });

      // Fjern det hashede password fra det objekt, der returneres til klienten
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { passwordHash, ...result } = user;
      return result;

    } catch (error) {
      // Håndter specifikke databasefejl, f.eks. hvis unique constraint fejler (selvom vi tjekker ovenfor)
      if (error && typeof error === 'object' && 'code' in error && error.code === 'P2002') { // Prisma's kode for unique constraint violation
        throw new ConflictException('En bruger med denne email eksisterer allerede (databasefejl).');
      }
      // Log den faktiske fejl internt
      console.error('Databasefejl under brugeroprettelse:', error);
      // Vis en generisk fejl til klienten
      throw new InternalServerErrorException('Der opstod en databasefejl under brugeroprettelse.');
    }
  }

  // Metode til at finde en bruger baseret på email (nyttig til login senere)
  async findOneByEmail(email: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { email },
    });
  }

  // Metode til at finde en bruger baseret på ID (nyttig til andre operationer senere)
  async findOneById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
    });
  }
}
</file>

<file path="apps/api/src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PersistenceModule } from './persistence/persistence.module';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      imports: [PersistenceModule],
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', async () => {
      expect(await appController.getHello()).toEqual({
        message: 'Hello World',
      });
    });
  });
});
</file>

<file path="apps/api/src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  async getHello(): Promise<{ message: string }> {
    return await this.appService.getHello();
  }
}
</file>

<file path="apps/api/src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  async getHello(): Promise<{ message: string }> {
    return { message: 'Hello World' };
  }
}
</file>

<file path="apps/api/test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="apps/api/test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path="apps/api/.eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    sourceType: 'module',
    tsconfigRootDir: __dirname,
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};
</file>

<file path="apps/api/.prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="apps/api/Dockerfile">
FROM node:16-alpine AS builder
RUN apk update
# Set working directory
WORKDIR /app
RUN yarn global add turbo
COPY . .
RUN turbo prune --scope=api --docker

# Add lockfile and package.json's of isolated subworkspace
FROM node:16-alpine AS installer
RUN apk update
WORKDIR /app
COPY --from=builder /app/out/json/ .
COPY --from=builder /app/out/yarn.lock ./yarn.lock
COPY --from=builder /app/turbo.json ./turbo.json
COPY --from=builder /app/apps/api/prisma ./prisma
RUN yarn install --frozen-lockfile
RUN yarn prisma generate 


FROM node:16-alpine AS sourcer
WORKDIR /app
COPY --from=installer /app/ .
COPY --from=builder /app/out/full/ .
COPY .gitignore .gitignore
RUN yarn turbo run build --scope=api --include-dependencies --no-deps

FROM node:16-alpine as runner
WORKDIR /app
COPY --from=sourcer /app/ .
CMD [ "node", "apps/api/dist/main.js" ]
</file>

<file path="apps/api/nest-cli.json">
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}
</file>

<file path="apps/api/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": [
    "node_modules",
    "../../node_modules",
    "test",
    "dist",
    "**/*spec.ts"
  ]
}
</file>

<file path="apps/api/tsconfig.json">
{
  "extends": "tsconfig/nestjs.json",
  "compilerOptions": {
    "outDir": "./dist",
    "baseUrl": "./"
  }
}
</file>

<file path="apps/web/pages/_app.tsx">
import type { AppProps } from "next/app";
import { Provider } from "react-redux";
import store from "../src/store";
import "../src/styles/global.css";

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <Provider store={store}>
      <Component {...pageProps} />;
    </Provider>
  );
}

export default MyApp;
</file>

<file path="apps/web/pages/index.tsx">
import { Button } from "ui";
import { useHelloQuery } from "../src/store/services/api";

export default function Web() {
  const { data } = useHelloQuery();

  return (
    <div>
      <h1>{data?.message}</h1>
      <Button />
    </div>
  );
}
</file>

<file path="apps/web/src/screens/auth/login/login.test.tsx">
import { render } from "@testing-library/react";
import { LoginScreen } from "./login";

test("render login component", () => {
  render(<LoginScreen />);
});
</file>

<file path="apps/web/src/screens/auth/login/login.tsx">
import { Button } from "ui";

export function LoginScreen() {
  return (
    <div>
      Login Screen <Button />
    </div>
  );
}
</file>

<file path="apps/web/src/store/services/api.ts">
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  reducerPath: "baseApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "api",
  }),
  tagTypes: [],
  endpoints: (builder) => ({
    hello: builder.query<{ message: string }, void>({
      query: () => ({
        url: "/",
      }),
    }),
  }),
});

export const { useHelloQuery } = api;
</file>

<file path="apps/web/src/store/index.ts">
import { configureStore } from "@reduxjs/toolkit";
import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";

import { api } from "./services/api";

export function makeStore() {
  return configureStore({
    reducer: {
      [api.reducerPath]: api.reducer,
    },

    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware().concat(api.middleware),
  });
}

const store = makeStore();

export type RootState = ReturnType<typeof store.getState>;

export type AppDispatch = typeof store.dispatch;

export const useAppDispatch = () => useDispatch<AppDispatch>();

export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export default store;
</file>

<file path="apps/web/src/styles/global.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="apps/web/.eslintrc.js">
module.exports = require("config/eslint-preset");
</file>

<file path="apps/web/Dockerfile">
FROM node:16-alpine AS builder
RUN apk update
# Set working directory
WORKDIR /app
RUN yarn global add turbo
COPY . .
# Only Take packages that are needed to compile this app
RUN turbo prune --scope=web --docker

# Add lockfile and package.json's of isolated subworkspace
FROM node:16-alpine AS installer
RUN apk update
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY --from=builder /app/out/json/ .
COPY --from=builder /app/out/yarn.lock ./yarn.lock
COPY --from=builder /app/turbo.json ./turbo.json
RUN yarn install --frozen-lockfile


FROM node:16-alpine AS sourcer
RUN apk update
WORKDIR /app
COPY --from=installer /app/ .
COPY --from=builder /app/out/full/ .
COPY .gitignore .gitignore
RUN yarn turbo run build --scope=web --include-dependencies --no-deps

FROM node:16-alpine as runner
WORKDIR /app
COPY --from=sourcer /app/ .
WORKDIR /app/apps/web/
CMD [ "npm", "start" ]
</file>

<file path="apps/web/jest.config.js">
const nextJest = require("next/jest");

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: "./",
});

// Add any custom config to be passed to Jest
const customJestConfig = {
  // Add more setup options before each test is run
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  // if using TypeScript with a baseUrl set to the root directory then you need the below for alias' to work
  moduleDirectories: ["node_modules", "<rootDir>/"],
  testEnvironment: "jest-environment-jsdom",
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig);
</file>

<file path="apps/web/jest.setup.js">
// Optional: configure or set up a testing framework before each test.
// If you delete this file, remove `setupFilesAfterEnv` from `jest.config.js`

// Used for __tests__/testing-library.js
// Learn more: https://github.com/testing-library/jest-dom
import "@testing-library/jest-dom/extend-expect";
</file>

<file path="apps/web/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
</file>

<file path="apps/web/next.config.js">
const withTM = require("next-transpile-modules")(["ui"]);

module.exports = withTM({
  reactStrictMode: true,
});
</file>

<file path="apps/web/postcss.config.js">
module.exports = require("config/postcss.config");
</file>

<file path="apps/web/README.md">
## Getting Started

First, run the development server:

```bash
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.js`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.js`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_source=github.com&utm_medium=referral&utm_campaign=turborepo-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/web/tailwind.config.js">
module.exports = require("config/tailwind.config");
</file>

<file path="apps/web/tsconfig.json">
{
  "extends": "tsconfig/nextjs.json",
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", "jest.setup.js"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/config/eslint-preset.js">
module.exports = {
  extends: ["next", "prettier"],
  settings: {
    next: {
      rootDir: ["apps/*/", "packages/*/"],
    },
  },
  rules: {
    "@next/next/no-html-link-for-pages": "off",
    "react/jsx-key": "off",
  },
};
</file>

<file path="packages/config/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="packages/config/tailwind.config.js">
module.exports = {
  content: [
    "../../packages/ui/**/*.{js,ts,jsx,tsx}",
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="packages/tsconfig/base.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "composite": false,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "node",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["node_modules"]
}
</file>

<file path="packages/tsconfig/nestjs.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "./base.json",
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

<file path="packages/tsconfig/nextjs.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Next.js",
  "extends": "./base.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "module": "esnext",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": ["src", "next-env.d.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/tsconfig/package.json">
{
  "name": "tsconfig",
  "version": "0.0.0",
  "private": true,
  "main": "index.js",
  "files": [
    "base.json",
    "nextjs.json",
    "react-library.json"
  ]
}
</file>

<file path="packages/tsconfig/react-library.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./base.json",
  "compilerOptions": {
    "lib": ["ES2015"],
    "module": "ESNext",
    "target": "ES6",
    "jsx": "react-jsx"
  }
}
</file>

<file path="packages/tsconfig/README.md">
# `tsconfig`

These are base shared `tsconfig.json`s from which all other `tsconfig.json`'s inherit from.
</file>

<file path="packages/ui/components/Button/Button.tsx">
export const Button = () => {
  return <button className="text-lg bg-red-500">boo</button>;
};
</file>

<file path="packages/ui/index.tsx">
export * from "./components/Button/Button";
</file>

<file path="packages/ui/tsconfig.json">
{
  "extends": "tsconfig/react-library.json",
  "include": ["."],
  "exclude": ["dist", "build", "node_modules"]
}
</file>

<file path=".dockerignore">
**/node_modules
**/.next
**/dist
**/.turbo
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
node_modules
.pnp
.pnp.js

# testing
coverage

# next.js
.next/
out/
build

**/dist
**/.env

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# turbo
.turbo
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2022 Ejaz Ahmed

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="turbo.json">
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "lint": {
      "outputs": []
    },
    "dev": {
      "cache": false
    },
    "test:ci": {
      "cache": false
    }
  }
}
</file>

<file path=".github/workflows/api.yaml">
name: api-ci

on:
  push:
    branches: [master]
    paths:
      - "apps/api/**"
  pull_request:
    branches: [master]
    paths:
      - "apps/api/**"
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: "postgresql://test:test@localhost:5433/mydb"

    strategy:
      matrix:
        node-version: [16.x]

    steps:
      - uses: actions/checkout@v2

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}

      - name: Get yarn cache directory path
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Cache node modules
        uses: actions/cache@v2
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - run: yarn global add turbo
      - run: npx nps prepare.ci.api
      - run: npx nps build.ci.api
      - run: npx nps test.ci.api
</file>

<file path="apps/api/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  passwordHash String
  name         String?
  role         Role     @default(USER)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum Role {
  USER
  ADMIN
}
</file>

<file path="apps/api/src/persistence/prisma/prisma.service.ts">
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}
</file>

<file path="apps/api/src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { validationSchemaForEnv } from './config/environment-variables';
import { PersistenceModule } from './persistence/persistence.module';
import { UsersModule } from './users/users.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: validationSchemaForEnv,
    }),
    PersistenceModule,
    UsersModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

<file path="apps/api/webpack-hmr.config.js">
/* eslint-disable @typescript-eslint/no-var-requires */
const nodeExternals = require('webpack-node-externals');
const { RunScriptWebpackPlugin } = require('run-script-webpack-plugin');

module.exports = function (options, webpack) {
  return {
    ...options,
    entry: ['webpack/hot/poll?100', options.entry],
    externals: [
      nodeExternals({
        allowlist: ['webpack/hot/poll?100'],
        modulesDir: '../../node_modules',
      }),
    ],
    plugins: [
      ...options.plugins,
      new webpack.HotModuleReplacementPlugin(),
      new webpack.WatchIgnorePlugin({
        paths: [/\.js$/, /\.d\.ts$/],
      }),
      new RunScriptWebpackPlugin({ name: options.output.filename }),
    ],
  };
};
</file>

<file path="packages/config/nginx.conf">
events {

}

http {

    server {
        listen 80;
        server_name localhost;

        location /api/ {
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://host.docker.internal:5002/;

            proxy_http_version 1.1;
            proxy_set_header Connection "upgrade";
            proxy_set_header Upgrade $http_upgrade;
        }

        location /_next/webpack-hmr {
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;


            proxy_pass http://host.docker.internal:3000;

            proxy_http_version 1.1;
            proxy_set_header Connection "upgrade";
            proxy_set_header Upgrade $http_upgrade;
        }

        location / {
            proxy_pass http://host.docker.internal:3000;
        }

    }

}
</file>

<file path="terminal.txt">
[{
	"resource": "/Users/Yousef_1/Desktop/LearningLab/LearningLab/apps/api/src/users/users.module.ts",
	"owner": "typescript",
	"code": "2307",
	"severity": 8,
	"message": "Cannot find module '../../persistence/persistence.module' or its corresponding type declarations.",
	"source": "ts",
	"startLineNumber": 5,
	"startColumn": 35,
	"endLineNumber": 5,
	"endColumn": 73
}]
</file>

<file path="apps/api/src/main.ts">
// apps/api/src/main.ts
import { Logger, ValidationPipe } from '@nestjs/common'; // Importer ValidationPipe
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

declare const module: any; // For HMR (Hot Module Replacement)

async function bootstrap() {
  const logger = new Logger('EntryPoint');
  const app = await NestFactory.create(AppModule);

  // Global Validation Pipe
  // Dette sikrer, at alle indkommende data til controllere valideres
  // baseret på DTO'er (Data Transfer Objects) og class-validator decorators.
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // Fjerner automatisk properties, der ikke er defineret i DTO'en.
      forbidNonWhitelisted: true, // Kaster en fejl, hvis der sendes properties, der ikke er i DTO'en.
      transform: true, // Transformer automatisk indkommende data til DTO-instanser.
      transformOptions: {
        enableImplicitConversion: true, // Tillader implicit konvertering af typer (f.eks. string fra URL-parametre til number).
      },
    }),
  );

  // Swagger API Dokumentation Setup
  // Swagger (OpenAPI) bruges til at generere interaktiv API-dokumentation.
  const swaggerConfig = new DocumentBuilder()
    .setTitle('Læringsplatform API') // Opdateret titel for API-dokumentationen
    .setDescription('API Dokumentation for den avancerede læringsplatform') // Opdateret beskrivelse
    .setVersion('1.0')
    .addBearerAuth() // Tilføjer mulighed for at specificere Bearer Token (JWT) i Swagger UI, forbereder til autentificering
    .build();

  const document = SwaggerModule.createDocument(app, swaggerConfig);
  // Gør API-dokumentationen tilgængelig på /docs endpointet (f.eks. http://localhost/api/docs via Nginx)
  SwaggerModule.setup('docs', app, document);

  // Sæt porten for API'en. Brug miljøvariablen PORT hvis den er sat, ellers default til 5002.
  const PORT = process.env.PORT || 5002;

  await app.listen(PORT);

  // HMR (Hot Module Replacement) opsætning (kun for udvikling)
  // Dette tillader moduler at blive genindlæst uden at genstarte hele applikationen.
  if (module.hot) {
    module.hot.accept();
    module.hot.dispose(() => app.close());
  }

  // Log-beskeder til terminalen for at vise, at serveren kører.
  logger.log(`NestJS API server kører internt på http://localhost:${PORT}`);
  logger.log(`API Dokumentation (internt) er tilgængelig på http://localhost:${PORT}/docs`);
  logger.log(`Hele applikationen (via Nginx) burde være tilgængelig på http://localhost`);
  logger.log(`API'en (via Nginx) burde være tilgængelig på http://localhost/api/`);
}
bootstrap();
</file>

<file path="packages/config/package.json">
{
  "name": "config",
  "version": "0.0.0",
  "main": "index.js",
  "license": "MIT",
  "files": [
    "eslint-preset.js"
  ],
  "dependencies": {
    "eslint-config-next": "^13.4.12",
    "eslint-config-prettier": "^8.9.0",
    "eslint-plugin-react": "7.33.1"
  }
}
</file>

<file path="packages/ui/package.json">
{
  "name": "ui",
  "version": "0.0.0",
  "main": "./index.tsx",
  "types": "./index.tsx",
  "license": "MIT",
  "devDependencies": {
    "@types/react": "^18.2.18",
    "@types/react-dom": "^18.2.7",
    "config": "*",
    "tsconfig": "*",
    "typescript": "^5.1.6"
  }
}
</file>

<file path="docker-compose.yml">
services:
  reverse-proxy:
    image: nginx:latest
    container_name: nginx_container
    ports:
      - 80:80
    depends_on:
      - postgres
    volumes:
      - ./packages/config/nginx.conf:/etc/nginx/nginx.conf
    extra_hosts:
      - "host.docker.internal:host-gateway"

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test
    volumes:
      - db_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"

volumes:
  db_data:
</file>

<file path="package-scripts.js">
const path = require("path");

const apiPath = path.resolve(__dirname, "apps/api");
const webPath = path.resolve(__dirname, "apps/web");

const ciApiPath = path.resolve(__dirname, "out/apps/api");
const ciWebPath = path.resolve(__dirname, "out/apps/web");

module.exports = {
  scripts: {
    prepare: {
      default: `nps prepare.web prepare.api`,
      web: `yarn`,
      api: `nps prepare.docker prisma.migrate.dev`,
      docker: "docker compose up -d",
      ci: {
        web: `npx turbo prune --scope=web && cd out && yarn install --frozen-lockfile`,
        api: `npx turbo prune --scope=api && cd out && yarn install --frozen-lockfile && nps prisma.generate`,
      },
    },
    test: {
      default: `nps test.web test.api`,
      web: `cd ${webPath} && yarn test`,
      api: `cd ${apiPath} && yarn test`,
      ci: {
        default: `nps test.ci.web test.ci.api`,
        web: `cd ${ciWebPath} && yarn test:ci`,
        api: `cd ${ciApiPath} && yarn test:ci`,
      },
      watch: {
        default: `nps test.watch.web test.watch.api`,
        web: `cd ${webPath} && yarn test:watch`,
        api: `cd ${apiPath} && yarn test:watch`,
      },
    },
    prisma: {
      generate: `cd ${apiPath} && npx prisma generate`,
      studio: `cd ${apiPath} && npx prisma studio`,
      migrate: {
        dev: `cd ${apiPath} && npx prisma migrate dev`,
      },
    },
    build: {
      default: "npx turbo run build",
      ci: {
        web: "cd out && npm run build",
        api: "cd out && npm run build",
      },
    },
    docker: {
      build: {
        default: "nps docker.build.web docker.build.api",
        web: `docker build -t web . -f ${webPath}/Dockerfile`,
        api: `docker build -t api . -f ${apiPath}/Dockerfile`,
      },
    },
    dev: "npx turbo run dev",
  },
};
</file>

<file path="package.json">
{
  "name": "turborepo-basic-shared",
  "version": "0.0.0",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev --parallel",
    "lint": "turbo run lint",
    "format": "prettier --write \"**/*.{ts,tsx,md}\""
  },
  "devDependencies": {
    "prettier": "^3.0.0",
    "prisma": "^5.1.0",
    "turbo": "1.10.12"
  },
  "engines": {
    "npm": ">=7.0.0",
    "node": ">=14.0.0"
  },
  "packageManager": "yarn@1.22.17"
}
</file>

<file path="apps/api/package.json">
{
  "name": "api",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "dev": "nest build --webpack --webpackPath webpack-hmr.config.js --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch --runInBand",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json --runInBand",
    "test:ci": "jest --ci --runInBand"
  },
  "dependencies": {
    "@nestjs/common": "^10.1.3",
    "@nestjs/config": "^3.0.0",
    "@nestjs/core": "^10.1.3",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^10.1.3",
    "@nestjs/swagger": "^7.1.6",
    "@prisma/client": "^5.1.0",
    "bcryptjs": "^3.0.2",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "joi": "^17.9.2",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.1.13",
    "rimraf": "^5.0.1",
    "rxjs": "^7.8.1",
    "swagger-ui-express": "^5.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.1.11",
    "@nestjs/schematics": "^10.0.1",
    "@nestjs/testing": "^10.1.3",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.3",
    "@types/node": "^20.4.5",
    "@types/passport-jwt": "^4.0.1",
    "@types/passport-local": "^1.0.38",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^6.2.1",
    "@typescript-eslint/parser": "^6.2.1",
    "eslint": "^8.46.0",
    "eslint-config-prettier": "^8.9.0",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.6.2",
    "prettier": "^3.0.0",
    "prisma": "^5.1.0",
    "run-script-webpack-plugin": "^0.2.0",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.1",
    "ts-loader": "^9.4.4",
    "ts-node": "^10.9.1",
    "tsconfig": "*",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.6",
    "webpack": "^5.88.2",
    "webpack-node-externals": "^3.0.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="apps/web/package.json">
{
  "name": "web",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^1.9.5",
    "next": "13.4.12",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-redux": "^8.1.2",
    "ui": "*"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "14.4.3",
    "@types/node": "^20.4.5",
    "@types/react": "18.2.18",
    "autoprefixer": "^10.4.14",
    "config": "*",
    "eslint": "8.46.0",
    "jest": "^29.6.2",
    "jest-environment-jsdom": "^29.6.2",
    "next-transpile-modules": "10.0.1",
    "postcss": "^8.4.27",
    "tailwindcss": "^3.3.3",
    "tsconfig": "*",
    "typescript": "^5.1.6"
  }
}
</file>

<file path="README.md">
# Turborepo (NestJS + Prisma + NextJS + Tailwind + Typescript + Jest) Starter

This is fullstack turborepo starter. It comes with the following features. 

- ✅ Turborepo 
- ✅ Nestjs 
    - ✅ Env Config with Validation  
    - ✅ Prisma 
- ✅ NextJS 
    - ✅ Tailwind 
    - ✅ Redux Toolkit Query 
- ✅ Testing using Jest 
- ✅ Github Actions 
- ✅ Reverse Proxy using Nginx 
- ✅ Docker Integration 
- ✅ Postgres Database 
- ✅ Package scripts using NPS 

## What's inside?

This turborepo uses [Yarn](https://classic.yarnpkg.com/lang/en/) as a package manager. It includes the following packages/apps:

### Apps and Packages

- `api`: a [NestJS](https://nestjs.com/) app
- `web`: a [Next.js](https://nextjs.org) app
- `ui`: a stub React component library used by `web`.
- `config`: `eslint`, `nginx` and `tailwind` (includes `eslint-config-next` and `eslint-config-prettier`)
- `tsconfig`: `tsconfig.json`s used throughout the monorepo

Each package/app is 100% [TypeScript](https://www.typescriptlang.org/).

### Utilities

This turborepo has some additional tools already setup for you:

- [Node Package Scripts](https://github.com/sezna/nps#readme) for automation scripts
- [TypeScript](https://www.typescriptlang.org/) for static type checking
- [ESLint](https://eslint.org/) for code linting
- [Prettier](https://prettier.io) for code formatting

## Setup
This starter kit is using turborepo and yarn workspaces for monorepo workflow.

### Prerequisites 
- Install nps by running 
```
npm i -g nps
```
- Make sure docker and docker-compose are
 installed. Refer to docs for your operating system.

### Configure Environment
- Frontend 
    - `cd apps/web && cp .env.example .env`
- Backend 
    - `cd apps/api && cp .env.example .env`

### Install Dependencies
Make sure you are at root of the project and just run 

```
nps prepare
```
### Build

To build all apps and packages, run the following command at the root of project:

```
nps build
```

### Develop

To develop all apps and packages, run the following command at the root of project:

```
nps dev
```
The app should be running at `http://localhost` with reverse proxy configured.


## Other available commands
Run `nps` in the terminal to see list of all available commands.
</file>

</files>
