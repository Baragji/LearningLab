generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   Int            @id @default(autoincrement())
  email                String         @unique
  name                 String?
  createdAt            DateTime       @default(now())
  passwordHash         String
  role                 Role           @default(USER)
  updatedAt            DateTime       @updatedAt
  passwordResetExpires DateTime?
  passwordResetToken   String?        @unique
  quizAttempts         QuizAttempt[]
  progress             UserProgress[]
}

model SubjectArea {
  id        Int      @id @default(autoincrement())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  courses   Course[]
}

model Course {
  id            Int         @id @default(autoincrement())
  title         String
  description   String
  slug          String      @unique
  subjectAreaId Int
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  subjectArea   SubjectArea @relation(fields: [subjectAreaId], references: [id])
  modules       Module[]
}

model Module {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  order       Int
  courseId    Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lessons     Lesson[]
  course      Course   @relation(fields: [courseId], references: [id])
  quizzes     Quiz[]   @relation("ModuleQuizzes")
}

model Lesson {
  id            Int            @id @default(autoincrement())
  title         String
  description   String
  order         Int
  moduleId      Int
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  contentBlocks ContentBlock[]
  module        Module         @relation(fields: [moduleId], references: [id])
  quizzes       Quiz[]         @relation("LessonQuizzes")
  userProgress  UserProgress[] @relation("LessonProgress")
}

model ContentBlock {
  id        Int              @id @default(autoincrement())
  type      ContentBlockType
  content   String
  order     Int
  lessonId  Int
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  lesson    Lesson           @relation(fields: [lessonId], references: [id])
}

model Quiz {
  id           Int            @id @default(autoincrement())
  title        String
  description  String
  lessonId     Int?
  moduleId     Int?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  questions    Question[]
  lesson       Lesson?        @relation("LessonQuizzes", fields: [lessonId], references: [id])
  module       Module?        @relation("ModuleQuizzes", fields: [moduleId], references: [id])
  attempts     QuizAttempt[]
  userProgress UserProgress[] @relation("QuizProgress")
}

model Question {
  id            Int            @id @default(autoincrement())
  text          String
  type          QuestionType
  quizId        Int
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  answerOptions AnswerOption[]
  quiz          Quiz           @relation(fields: [quizId], references: [id])
  userAnswers   UserAnswer[]
}

model AnswerOption {
  id          Int          @id @default(autoincrement())
  text        String
  isCorrect   Boolean
  questionId  Int
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  question    Question     @relation(fields: [questionId], references: [id])
  userAnswers UserAnswer[]
}

model QuizAttempt {
  id          Int            @id @default(autoincrement())
  userId      Int
  quizId      Int
  score       Int            @default(0)
  startedAt   DateTime       @default(now())
  completedAt DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  quiz        Quiz           @relation(fields: [quizId], references: [id])
  user        User           @relation(fields: [userId], references: [id])
  userAnswers UserAnswer[]
  progress    UserProgress[] // Relation til UserProgress hvis et forsøg direkte opdaterer EN UserProgress post
}

model UserAnswer {
  id                     Int           @id @default(autoincrement())
  quizAttemptId          Int
  questionId             Int
  selectedAnswerOptionId Int?
  inputText              String?
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt
  question               Question      @relation(fields: [questionId], references: [id])
  quizAttempt            QuizAttempt   @relation(fields: [quizAttemptId], references: [id])
  selectedAnswerOption   AnswerOption? @relation(fields: [selectedAnswerOptionId], references: [id])

  @@unique([quizAttemptId, questionId], name: "userAnswer_quizAttemptId_questionId_unique")
}

model UserProgress {
  id            Int            @id @default(autoincrement())
  userId        Int
  lessonId      Int?
  quizId        Int?
  status        ProgressStatus @default(NOT_STARTED)
  score         Int?
  quizAttemptId Int?           @unique // Gør denne unik hvis ét forsøg kun kan linke til én UserProgress
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  user          User          @relation(fields: [userId], references: [id])
  lesson        Lesson?       @relation("LessonProgress", fields: [lessonId], references: [id])
  quiz          Quiz?         @relation("QuizProgress", fields: [quizId], references: [id])
  quizAttempt   QuizAttempt?  @relation(fields: [quizAttemptId], references: [id])

  @@unique([userId, lessonId, quizId], name: "userId_lessonId_quizId_unique_constraint")
}

enum Role {
  USER
  ADMIN
}

enum ContentBlockType {
  TEXT
  IMAGE_URL
  VIDEO_URL
  QUIZ_REF
}

enum QuestionType {
  MULTIPLE_CHOICE
  FILL_IN_BLANK
  MATCHING
}

enum ProgressStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}
